# MSA 서비스 설계

## 개요

- 현재 모놀리틱 아키텍처 형태에서 추후 서비스가 확장되어 MSA 형태로 전환했을 때의 서비스 설계
- MSA 설계 시 도메인 분리와 그에 따른 트랜잭션, 락 등 한계에 대한 처리 방안

## MSA란?

- MicroService Architecture의 줄임 말
- 여러 개의 작은 서비스로 구성되어 각 서비스가 독립적으로 개발되고 배포되는 구조

### 장점

- 각각의 서비스 별로 나누어서 개발 및 배포를 하기 때문에 다른 서비스에 영향을 주지 않고 빠르게 개발 및 배포 할 수 있다.
- 모놀리틱 아키텍처의 경우 어떤 특정 서비스 때문에 많은 트래픽이 예상되어 서버가 더 필요할 때 전체 시스템의 서버가 증가하게 되는데  MSA를 적용할 경우 해당 서비스의 서버만 증설하면 되기 때문에 서버를 최적화 하여 관리할 수 있다.
- DB도 서비스 별로 분리 되기 때문에 DB 트래픽 관리에 용이하다.

### 단점

- 개발 및 관리에 복잡성이 증가한다.
- 서비스가 독립적으로 분리되어 있기 때문에 서비스 간 통신이 필요하다.
- DB가 서비스마다 분리가 되는데 DB 간에 트랜잭션, 롤백, 락 등에 제한 사항이 따른다.

### SAGA 패턴

- 각 서비스 별로 트랜잭션을 처리 하고 트랜잭션이 종료 되었을 때 이벤트를 발행하여 완료 되었음을 다른 서비스에게 알린다.
- 트랜잭션이 실패했을 때에는 트랜잭션 실패 이벤트를 발행하고, 이벤트를 수신한 서비스는 보상 트랜잭션을 수행한다.

1. 코레오그래피(Choreography)
    - 각 서비스의 트랜잭션 종료 시 이벤트를 발행, 해당 이벤트를 구독 하는 서비스는 이벤트를 받은 뒤 필요한 작업 수행
    - 트랜잭션 실패 시 실패 이벤트를 발행해서 보상 트랜잭션 수행
    - 장점
        - 느슨한 결합으로 확장성이 높다.
    - 단점
        - 전체적인 시스템 흐름 파악이 어렵다.
        - 트랜잭션 관리가 복잡하다.

1. 오케스트레이션(Orchestration)
    - 중앙 오케스트레이터가 트랜잭션을 관리 및 제어하여 각 서비스에 트랜잭션을 요청
    - 장점
        - 중앙 오케스트레이터를 통해 트랜잭션을 관리 하기 용이하다.
        - 전체적인 시스템 흐름을 파악하기 용이하다.
    - 단점
        - 중앙 오케스트레이터에 장애가 생기면 전체 서비스에 문제가 생길 수 있음.
        - 서비스가 결합되어있기 때문에 확장성이 낮음.
        

## 도메인 목록

| 도메인 | User | Coupon | Order | Payment | Product |
| --- | --- | --- | --- | --- | --- |
| 책임 | 회원정보, 잔액관리 | 쿠폰 발행, 사용, 목록 | 주문 생성, 완료, 취소 | 결제 | 상품 관리 |


## 이벤트 적용 시 다이어 그램

![image](https://github.com/user-attachments/assets/581b1c37-004a-4812-97e5-e36c55bd99a1)

- 주문 프로세스
    1. 재고 차감
        1. 사용자 주문 요청 시 상품 도메인에서 재고 확인
        2. 재고 부족 시 실패 반환
        3. 재고 충분 시 재고 차감 후 성공 이벤트 발행
    2. 주문 생성
        1. 주문 도메인에서 주문 정보 저장
        2. 주문 생성 실패 시 실패 이벤트 발행 → 상품 도메인 보상 트랜잭션 실행 → 재고 복구
        3. 주문 생성 성공 시 쿠폰 사용 API 호출 (할인 금액이 필요함에 따라 이벤트가 아닌 API 호출출)
    3. 쿠폰 사용
        1. 쿠폰 사용 가능 여부 확인
        2. 사용 불가능 할 경우 실패 리턴 → 주문 롤백 후 실패 이벤트 발행
        3. 사용 성공 시 할인 금액 리턴 → 최종 주문 금액 저장
- 결제 프로세스
    1. 잔액 차감
        1. 사용자 결제 요청 시 유저 도메인에서 잔액 확인
        2. 잔액 부족 시 실패 반환
        3. 잔액 충분 시 성공 이벤트 발행
    2. 결제 생성
        1. 결제 도메인에서 결제 정보 저장
        2. 실패 생성 실패 시 실패 이벤트 발행 → 유저 도메인 보상 트랜잭션 실행 → 잔액 복구
        3. 결제 성공 시 성공 이벤트 발행
    3. 주문 완료
        1. 최종 주문 완료 처리
        2. 실패 시 실패 이벤트 발행 → 결제 도메인 보상 트랜잭션 → 유저 도메인 보상 트랜잭션
        3. 성공 이벤트 발행 → 데이터 플랫폼, Redis 랭킹 반영
      
- 서비스를 분리함에 따라 각 서비스를 이벤트로 연결 하였고, 순서를 보장하는 방식으로 이벤트 설계를 진행 따라서 서비스가 실패했을 경우 역순으로 실패 이벤트를 발행하여 보상 트랜잭션 실행하게끔 설계
